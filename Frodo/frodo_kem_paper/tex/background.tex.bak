\section{Preliminaries}
In this section we review the theoretical background that is relevant for our work. We explain the LWE problem and how it is used in the key encapsulation protocol \textsf{FrodoKEM}.

\subsection{Notation}
In this work, we adopt most of the notation that is used in the official specification of \textsf{FrodoKEM}~\cite{frodo-nist}. Each time we refer to the version of Frodo that was submitted to NIST, we state \textsf{FrodoKEM}, \textsf{FrodoCCS} on the other hand refers to the version of Frodo published at CCS'16 \cite{DBLP:conf/ccs/BosCDMNNRS16}. Similary, \textsf{NewHopeNIST} refers to the NIST submission of NewHope \cite{NISTPQC-R1:NewHope17} whereas \textsf{NewHopeUSENIX} refers to the version that was published at USENIX'16 \cite{DBLP:conf/uss/AlkimDPS16}. We use bold lower-case letters to denote vectors and bold upper-case letters to denote matrices. We denote the set of all integers by $\mathbb{Z}$ and by $\mathbb{Z}_q$ we denote the quotient ring of integers modulo $q$. For two $n$-dimensional vectors $\mathbf{a}, \mathbf{b}$ their inner product is denoted by $\langle \mathbf{a},\mathbf{b} \rangle = \sum\nolimits_{i=0}^{n-1} \mathbf{a}_i \mathbf{b}_i$. The concatenation of two vectors $\mathbf{a},\mathbf{b}$ is denoted with the $||$-operator.


\subsection{The Learning with Errors problem}
In 2005, Regev introduced the Learning with Errors (LWE) problem \cite{DBLP:conf/stoc/Regev05}. The LWE problem is defined in \cite{DBLP:conf/coco/Regev10} as follows:
  \begin{quote}
  Fix a size parameter $n\geq 1$, a modulus $q \geq 2$, and an ‘error’ probability distribution $\chi$ on $\mathbb{Z}_{q}$. Let $A_{s,\chi}$ on $\mathbb{Z}_{q}^{n} \times \mathbb{Z}_{q}$ be the probability distribution obtained by choosing a vector $\mathbf{a} \in \mathbb{Z}_{q}^{n}$ uniformly at random, choosing $\mathbf{\epsilon} \in \mathbb{Z}_{q}$ according to $\chi$, and outputting $(\mathbf{a}, \langle  \mathbf{a},\mathbf{s} \rangle + \mathbf{\epsilon})$, where additions are performed in $\mathbb{Z}_{q}$, i.e., modulo $q$. We say that an algorithm solves LWE with modulus $q$ and error distribution $\chi$ if, for any $s \in \mathbb{Z}_{q}^{n}$, given an arbitrary number of independent samples from $A_{s,\chi}$ it outputs $\mathbf{s}$ (with high probability).	
  \end{quote}
	
In other words, solving a system of linear equations is usually easy, but as soon as an error ($\epsilon$) is added to the equations, it becomes a hard mathematical problem. To date, there is no quantum algorithm known that could solve this problem in polynomial time. Therefore schemes based on LWE, with high enough parameters, are considered quantum-secure.

\subsection{The Frodo Key Encapsulation Mechanism scheme}
The key pair generation, encapsulation, and decapsulation of \textsf{FrodoKEM} are shown in Algorithms \ref{alg:keygen}, \ref{alg:encaps}, and \ref{alg:decaps}, respectively. There are some subroutines called by these algorithms. We explain them very briefly here and refer to the original specification \cite{frodo-nist} for details. Frodo.Gen() uniformly samples an $n \times n$ matrix. Another sampling algorithm (Frodo.SampleMatrix()) samples a matrix from a specific distribution that is defined in the parameter sets shown in Table \ref{tab:params}. Frodo.Pack() and Frodo.Unpack() transform a matrix into a bit string (i.e., a format suitable for transmission) and vice versa. Frodo.Encode() encodes a bit string as mod-$q$ integer matrix. It uses $B$ bits of the bit string to generate one element of the matrix. $B$ is defined by the parameter set. The inverse operation is Frodo.Decode().

The main operation of the key generation (Algorithm \ref{alg:keygen}) is the generation of the LWE sample $\mathbf{B} \leftarrow \mathbf{AS} + \mathbf{E}$, where $\mathbf{A}$ is a uniformly random matrix, and $\mathbf{E}$ and $\mathbf{S}$ are distributed according to $\chi$. $\mathbf{A}$ is generated by a pseudo-random number generator. The designers of \textsf{FrodoKEM} proposed to either instantiate it with AES or cSHAKE. $\mathbf{B}$ and the seed for the generation of $\mathbf{A}$ is then the public key and $\mathbf{S}$ the secret key. During encapsulation, three noise matrices are generated $\mathbf{S}^\prime$, $\mathbf{E}^\prime$, and $\mathbf{E}^{\prime\prime}$. Then, both parts of the public key, $\mathbf{A}$, and $\mathbf{B}$ are used to compute one part of the ciphertext each by computing $\mathbf{B}^\prime \leftarrow \mathbf{S}^\prime \mathbf{A} + \mathbf{E}^\prime$ and $\mathbf{V} \leftarrow \mathbf{S}^\prime \mathbf{B} + \mathbf{E}^{\prime\prime}$. An encoded random bit string $\mu$ gets added to $\mathbf{V}$. The shared symmetric key is then computed by hashing both ciphertexts and some salt. The decapsulation checks whether the input is a valid ciphertext by first decrypting $\mu$ and then trying to re-encrypt it and check whether both ciphertexts match. If so, the shared symmetric key is again generated by hashing both ciphertexts and the salt.

\begin{algorithm}[t]
\caption{The \textsf{FrodoKEM} key pair generation} \label{alg:keygen}
  \begin{algorithmic}[1]
  \Procedure{KeyGen}{$1^\ell$}
    \State Choose uniformly random seeds $\mathbf{s} || \text{seed}_\mathbf{E} || \mathbf{z} \leftarrow_\$ U(\{0,1\}^{\text{len}_\mathbf{s}+\text{len}_\mathbf{E}+\text{len}_\mathbf{z}})$
        \State Generate pseudo-random seed $\text{seed}_\mathbf{A} \leftarrow H(\mathbf{z})$
    \State Generate the matrix $\mathbf{A} \in \mathbb{Z}^{n \times n}_{q}$ via $\mathbf{A} \leftarrow \text{Frodo.Gen}(\text{seed}_\mathbf{A})$
	\State $\mathbf{S} \leftarrow \text{Frodo.SampleMatrix}(\text{seed}_\mathbf{E},n,\bar{n},T_\chi,1)$
	\State $\mathbf{E} \leftarrow \text{Frodo.SampleMatrix}(\text{seed}_\mathbf{E},n,\bar{n},T_\chi,2)$
	\State Compute $\mathbf{B} \leftarrow \mathbf{AS} + \mathbf{E}$
	\State Compute $\mathbf{b} \leftarrow \text{Frodo.Pack}(\mathbf{B})$
	\State \Return public key $pk \leftarrow \text{seed}_\mathbf{A} || \mathbf{b} $ and secret key $sk^\prime \leftarrow (\mathbf{s} || \text{seed}_\mathbf{A} || \mathbf{b}, \mathbf{S})$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[t]
\caption{The \textsf{FrodoKEM} encapsulation} \label{alg:encaps}
  \begin{algorithmic}[1]
    \Procedure{Encaps}{$pk=\text{seed}_\mathbf{A} || \mathbf{b}$}
	\State Choose a uniformly random key $\mu \leftarrow U(\{0,1\}^{\text{len}_\mu})$
	\State Generate pseudo-random values $\text{seed}_\mathbf{E} || \mathbf{k} || \mathbf{d} \leftarrow G(pk || \mu)$
	\State Sample error matrix $\mathbf{S}^\prime \leftarrow \text{Frodo.SampleMatrix}(\text{seed}_\mathbf{E},\bar{m},n,T_\chi,4)$
	\State Sample error matrix $\mathbf{E}^\prime \leftarrow \text{Frodo.SampleMatrix}(\text{seed}_\mathbf{E},\bar{m},n,T_\chi,5)$
	 \State Generate the matrix $\mathbf{A} \in \mathbb{Z}^{n \times n}_{q}$ via $\mathbf{A} \leftarrow \text{Frodo.Gen}(\text{seed}_\mathbf{A})$
	 \State Compute $\mathbf{B}^\prime \leftarrow \mathbf{S}^\prime \mathbf{A} + \mathbf{E}^\prime$
	 \State Compute $\mathbf{c}_1 \leftarrow \text{Frodo.Pack}(\mathbf{B}^\prime)$
	 \State Sample error matrix $\mathbf{E}^{\prime\prime} \leftarrow \text{Frodo.SampleMatrix}(\text{seed}_\mathbf{E},\bar{m},\bar{n},T_\chi,6	)$
	 \State Compute $\mathbf{B} \leftarrow \text{Frodo.Unpack}(\mathbf{b},n,\bar{n})$
	 \State Compute $\mathbf{V} \leftarrow \mathbf{S}^\prime \mathbf{B} + \mathbf{E}^{\prime\prime}$
	 \State Compute $\mathbf{C} \leftarrow \mathbf{V} + \text{Frodo.Encode}(\mu)$
	 \State Compute $\mathbf{c}_2 \leftarrow \text{Frodo.Pack}(\mathbf{C})$
	 \State Compute $\mathbf{ss} \leftarrow F(\mathbf{c}_1 || \mathbf{c}_2 || \mathbf{k} || \mathbf{d})$
	\State \Return ciphertext $\mathbf{c}_1 || \mathbf{c}_2 || \mathbf{d}$ and shared secret $\mathbf{ss}$
    \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{The \textsf{FrodoKEM} decapsulation} \label{alg:decaps}
  \begin{algorithmic}[1]
    \Procedure{Decaps}{$sk=(\mathbf{s} || \text{seed}_\mathbf{A} || \mathbf{b}, \mathbf{S}),\mathbf{c}_1 || \mathbf{c}_2 || \mathbf{d}$}
	 \State Compute $\mathbf{B}^\prime \leftarrow \text{Frodo.Unpack}(\mathbf{c}_1)$
	 \State Compute $\mathbf{C} \leftarrow \text{Frodo.Unpack}(\mathbf{c}_2)$
	 \State Compute $\mathbf{M} \leftarrow \mathbf{C} - \mathbf{B}^\prime \mathbf{S}$	
	 \State Compute $\mu^\prime \leftarrow \text{Frodo.Decode}(\mathbf{M})$	 
	 \State Parse $pk \leftarrow \text{seed}_\mathbf{A} || \mathbf{b}$
	 \State Generate pseudo-random values $\text{seed}^\prime_\mathbf{E} || \mathbf{k}^\prime || \mathbf{d}^\prime \leftarrow G(pk || \mu^\prime)$
	 
	\State Sample error matrix $\mathbf{S}^\prime \leftarrow \text{Frodo.SampleMatrix}(\text{seed}^\prime_\mathbf{E},\bar{m},n,T_\chi,4)$
	\State Sample error matrix $\mathbf{E}^\prime \leftarrow \text{Frodo.SampleMatrix}(\text{seed}^\prime_\mathbf{E},\bar{m},n,T_\chi,5)$
	 \State Generate the matrix $\mathbf{A} \in \mathbb{Z}^{n \times n}_{q}$ via $\mathbf{A} \leftarrow \text{Frodo.Gen}(\text{seed}_\mathbf{A})$
	 \State Compute $\mathbf{B}^{\prime\prime} \leftarrow \mathbf{S}^\prime \mathbf{A} + \mathbf{E}^\prime$
	 \State Sample error matrix $\mathbf{E}^{\prime\prime} \leftarrow \text{Frodo.SampleMatrix}(\text{seed}^\prime_\mathbf{E},\bar{m},\bar{n},T_\chi,6	)$
	 \State Compute $\mathbf{B} \leftarrow \text{Frodo.Unpack}(\mathbf{b},n,\bar{n})$
	 \State Compute $\mathbf{V} \leftarrow \mathbf{S}^\prime \mathbf{B} + \mathbf{E}^{\prime\prime}$
	 \State Compute $\mathbf{C}^\prime \leftarrow \mathbf{V} + \text{Frodo.Encode}(\mu^\prime)$
	 \If{$\mathbf{B}^\prime || \mathbf{C} = \mathbf{B}^{\prime\prime} || \mathbf{C}^\prime$ and $\mathbf{d} = \mathbf{d}^\prime$} 
	 	\State \Return shared secret $\mathbf{ss} \leftarrow F(\mathbf{c}_1 || \mathbf{c}_2 || \mathbf{k}^\prime || \mathbf{d})$
	\Else
		\State \Return shared secret $\mathbf{ss} \leftarrow F(\mathbf{c}_1 || \mathbf{c}_2 || \mathbf{s} || \mathbf{d})$
	\EndIf
    \EndProcedure

    \end{algorithmic}
\end{algorithm}

\subsection{Parameters}\label{sec:params}

The authors of \textsf{FrodoKEM} proposed two parameter sets to instantiate; \textsf{FrodoKEM-640} and \textsf{FrodoKEM-976}. Table \ref{tab:params} lists all parameters of both sets. \textsf{FrodoKEM-640} claims 128 bits of post-quantum security and \textsf{FrodoKEM-976} claims 192 bits of post-quantum security. Another distinction is whether the generation of the matrix $\mathbf{A}$ is done using AES or cSHAKE, the corresponding instantiations are named \textsf{FrodoKEM-AES} and \textsf{FrodoKEM-cSHAKE} respectively. As cSHAKE is used multiple times, the authors added a domain separator as input to cSHAKE to make the three contexts $H, G, F$ distinct from each other.

\begin{table}[tbhp]
\caption{Implemented \textsf{FrodoKEM} parameter sets.}
\label{tab:params}
\begin{center}
\begin{tabular}{|l|r|r|}
\hline
& \textsf{FrodoKEM-640} & \textsf{FrodoKEM-976}\\
\hline
$D$ & 15 & 16\\
$q$ & 32768 & 65536\\
$n$ & 640 & 976\\
$\bar{m} = \bar{n}$ & 8 & 8\\
$B$ & 2 & 3\\
$\text{len}_\mathbf{A}$ & 128 & 128\\
$\text{len}_{\mu} = l$ & 128 & 192\\
$\text{len}_\mathbf{E}$ & 128 & 192\\
$\text{len}_\mathbf{z}$ & 128 & 192\\
$\text{len}_\mathbf{s}$ & 128 & 192\\
$\text{len}_\mathbf{k}$ & 128 & 192\\
$\text{len}_\mathbf{d}$ & 128 & 192\\
$\text{len}_\mathbf{ss}$ & 128 & 192\\
$\text{len}_{\chi}$ & 16 & 16\\
$\chi$ & $\chi_{\text{FrodoKEM-640}}$ &$\chi_{\text{FrodoKEM-976}}$\\
$H$ & cSHAKE128($\cdot$, 128, 0) & cSHAKE256($\cdot$, 128, 0)\\
$G$ & cSHAKE128($\cdot$, 384, 3) & cSHAKE256($\cdot$, 576, 3)\\
$F$ & cSHAKE128($\cdot$, 128, 7) & cSHAKE256($\cdot$, 192, 7)\\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Error Sampling}
The coefficients of the noise matrices are sampled from a discrete, symmetric distribution on $\mathbb{Z}$ that approximates a rounded, zero-centered Gaussian distribution.
Each parameter set uses a different probability density function (PDF), both are shown in Table \ref{tab:error}.\\
In the implementation, each discrete PDF is modified into a discrete cumulative distribution function (CDF) to enable inversion sampling. A CDF $f(x)$ returns the probability for a value being $x$ or less. We will demonstrate in an example how the inversion sampling works for the \textsf{FrodoKEM-640} set. The CDF results in the table:\\ $D=\{4727, 13584, 20864, 26113, 29434, 31278, 32176, 32560, 32704, 32751, 32764, 32767\}$.\\ To sample one noise $x$ from the distribution, 16 random bits are required. The first 15 bits represent an unsigned, random value $y \in [0, 32767]$. The value of $x$ is determined by the smallest index $\tilde{x}$ of the table $D$ such that $y \leq D[\tilde{x}]$. To be resistant against simple side-channel attacks, the sampler iterates over the entire table $D$ while comparing the value of $y$. The last random bit specifies the sign of $x$.
 
   \begin{table}[h]
   	\begin{center}
   		\caption{Error distributions}
   		\label{tab:error}
			\resizebox{\columnwidth}{!}{
   		\begin{tabular}{ll|rrrrrrrrrrrr}
   			\toprule
	   						  & $\sigma$   & \multicolumn{12}{c}{Probability of (in multiples of $2^{-15}$) }						  \\
							  &	    &	0       & $\pm$1 & $\pm$2 & $\pm$3 & $\pm$4 & $\pm$5 & $\pm$6  & $\pm$7 	& $\pm$8 	& $\pm$9 	& $\pm$10 	& $\pm$11	 \\		
   			\midrule
   			$\chi_{\text{FrodoKEM-640}}$ 	  & 2.75  & 9456    & 8857	    & 7280    & 5249      & 3321	&  1844    & 898 	& 384 		&  144 	& 47		& 13 		& 3 		 \\
   			$\chi_{\text{FrodoKEM-976}}$	  & 2.3    & 11278  & 10277   & 7774    & 4882      & 2545     & 1101     & 396 	& 118		& 29   		& 6    		& 1  		&    		 \\
   			\bottomrule 
   		\end{tabular}
			}
   	\end{center}
   \end{table}
   
\subsection{Structured Lattices} \label{sec:ringvsstandard}

For comparison reasons, it is prudent to discuss the differences between the ``standard'' LWE problem and the Ring-LWE problem. This is due to comparisons we draw to \textsf{NewHopeNIST} \cite{DBLP:conf/uss/AlkimDPS16,NISTPQC-R1:NewHope17}, a Ring-LWE KEM submitted to NIST for post-quantum standardisation. 

In Ring-LWE, the operating lattice is an \emph{ideal} lattice, which is a subset of (standard) lattices, computationally related to polynomials via matrices of a specific form. Thus, instead of having a matrix of the form $\mathbf{A} \in \mathbb{Z}^{n \times n}_q$, identically and independently distributed, we use a matrix that is structured in such a way that one column $\mathbf{a}_1 \in \mathbb{Z}^n_q$ can be used. The remaining $n-1$ columns are then derived as the coefficient representation of the polynomial $\mathbf{a}_1 \mathbf{x}^i$ in the ring $\mathbb{Z}_q / \langle f \rangle$, for some univariate polynomial \cite{lyu12}. Hence, we are able to represent matrices from the standard LWE problem as polynomials in the Ring-LWE problem. To date, there has been no significant attacks to exploit this added structure.

Once polynomials are utilised, more efficient multiplication techniques can be used, such as the Number Theoretic Transform (NTT) multiplier. This reduces the multiplication complexity from quadratic $(\mathcal{O}(n^2))$, to quasi-linear $(n \log (n))$, for an $n$ input multiplication. This, coupled with the significantly smaller key requirements, means that \textsf{NewHopeNIST} is more efficient than \textsf{FrodoKEM}.
